<!DOCTYPE html>
<html lang="es">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Programación dinámica</title>
  <meta name="description" content="Página de la materia Algoritmos y Programación II, curso Buchwald. Facultad de Ingeniería, Universidad de Buenos Aires.">

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        crossorigin="anonymous" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
  <link rel="stylesheet" href="/algo2/assets/main.css" type="text/css" />
  <link rel="shortcut icon" href="/algo2/assets/img/favicon.ico" type="image/x-icon">
  <!-- <link rel="canonical" href="http://localhost:4000/algo2/material/guias/pd/"> -->

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
        crossorigin="anonymous" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
          crossorigin="anonymous" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
          crossorigin="anonymous" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"
          onload="renderMathInElement(document.body);"></script>
  
</head>


  <body>
    <header role="banner" class="sticky-top container-fluid px-1">
  <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <a class="navbar-brand d-lg-none" href="#">Algoritmos y Programación II</a>
    <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#sitenav"
            aria-controls="sitenav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="sitenav">
      <ul class="navbar-nav mr-auto mt-2 mt-lg-0 small mx-auto">
        <li class="nav-item "><a class="nav-link" href="/algo2/"><span class="fa fa-home"></span> Inicio</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/docentes/"><span class="fa fa-chalkboard-teacher"></span> Docentes</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/regimen/"><span class="fa fa-tasks"></span> Régimen</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/calendario/"><span class="fa fa-calendar-alt"></span> Calendario</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/tps/"><span class="fa fa-briefcase"></span> TPs</a></li>
        
        <li class="nav-item dropdown ">
          <a class="nav-link dropdown-toggle" href="#" role="button" id="matDropdown"
                                              data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <span class="fa fa-paperclip"></span> Material</a>
          <ul class="dropdown-menu">
            <li class=""><a class="dropdown-item" href="/algo2/bibliografia/"><span class="fa fa-book"></span> Bibliografía</a></li>
            <li class=""><a class="dropdown-item" href="/algo2/material/"><span class="fa fa-book-reader"></span> Apuntes del curso</a></li>
            <li class=""><a class="dropdown-item" href="/algo2/material/guias/"><span class="fa fa-dumbbell"></span> Guías de ejercicios</a></li>
            <li>
              <a class="dropdown-item" href="https://drive.google.com/drive/folders/0B0x0VPz_v-f_ekhhQUpkay13RnM?resourcekey=0-BqMLnLNd6T8lRDzv-VL4xA&usp=sharing" target="_blank"><span class="fab fa-google-drive"></span> Drive</a>
            </li>
            <li>
              <a class="dropdown-item" href="https://www.youtube.com/channel/UCnmq-CGB2lEiwxhpa_Q63qQ" target="_blank"><span class="fab fa-youtube"></span> Canal</a>
            </li>
            <li><a class="dropdown-item" href="/algo2/faq/"><span class="fas fa-question-circle"></span> FAQ</a></li>
          </ul>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" role="button" id="aluDropdown"
                                              data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <span class="fa fa-user-friends"></span> Alumno</a>
          <ul class="dropdown-menu">
            <li><a class="dropdown-item" href="https://algoritmos-rw.github.io/algo2_skel"><span class="fa fa-file-download"></span> Descargas</a></li>
            <li><a class="dropdown-item" href="https://algoritmos-rw.dijkstra.ar/entregas/"><span class="fa fa-file-upload"></span> Entregas</a></li>
            <li><a class="dropdown-item" href="https://algoritmos-rw.dijkstra.ar/notas/"><span class="fa fa-pencil-alt"></span> Notas</a></li>
          </ul>
        </li>
        <li class="nav-item "><a class="nav-link" href="/algo2/encuestas/"><span class="fa fa-poll"></span> Encuestas</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/infraestructura/"><span class="fa fa-network-wired"></span> Infraestructura</a></li>
        <li class="nav-item">
          <a href="https://github.com/algoritmos-rw/algo2/blob/master/material/guias/pd.md" class="nav-link" target="_blank"><span class="fab fa-github"></span> Editar en GitHub</a>
        </li>
      </ul>
    </div>
  </nav>
</header>


    <main class="container" role="main">
      <div class="row justify-content-center">
        <div class="col col-xl-8">
          <h1 class="no_toc" id="programación-dinámica">Programación dinámica</h1>

<h2 class="no_toc" id="contenidos">Contenidos</h2>

<ol id="markdown-toc">
  <li><a href="#ejercicio-resuelto" id="markdown-toc-ejercicio-resuelto">Ejercicio resuelto</a>    <ol>
      <li><a href="#solución" id="markdown-toc-solución">Solución</a>        <ol>
          <li><a href="#opción-1" id="markdown-toc-opción-1">Opción 1</a></li>
          <li><a href="#opción-2" id="markdown-toc-opción-2">Opción 2</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#ejercicios-propuestos" id="markdown-toc-ejercicios-propuestos">Ejercicios propuestos</a></li>
  <li><a href="#bibliografía-y-referencias" id="markdown-toc-bibliografía-y-referencias">Bibliografía y referencias</a></li>
</ol>

<h2 id="ejercicio-resuelto">Ejercicio resuelto</h2>

<p>Dado un número <em>n</em>, mostrar la cantidad más económica (con menos términos) de escribirlo como una suma de cuadrados. Indicar el orden del algoritmo implementado.
Nota: siempre es posible escribir a n como suma de <em>n</em> términos de la forma \(1^2\), por lo que siempre existe solución. Sin embargo, la expresión \(10 = 3^2 + 1^2\) es una manera más económica de escribirlo para <code class="language-plaintext highlighter-rouge">n = 10</code>, pues sólo tiene dos términos.</p>

<p>Además, tener en cuenta que no se piden los términos, sino la cantidad mínima de términos cuadráticos necesaria.</p>

<p>Posible ayuda: considerar que para formar el número 0 necesitamos 0 términos; y que \(10 = 9 + 1^2\), también \(10 = 6 + 2^2\), y también \(10 = 1 + 3^2\) ¡Si tan solo supiéramos la cantidad de términos para formar 9, 6 y 1. . . !</p>

<h3 id="solución">Solución</h3>
<p>Primero entendamos el problema: se nos pide escribir un número como una suma de cuadrados perfectos. Ante eso, sabemos que por ejemplo a 74 lo podemos escribir como 74 términos de \(1^2\), aunque claramente esa no va a ser la solución óptima.
Por fuerza bruta, deberíamos probar cada una de las combinaciones, y simplemente quedarnos con la mejor.</p>

<p>Ahora bien, hay dos formas de resolver este problema.</p>

<h4 id="opción-1">Opción 1</h4>

<p>A 74 lo podemos escribir como 73 + 1, también como 72 + 2, también como 71 + 3, etc… Entonces simplemente tenemos que verificar cuántos términos son necesarios para escribir cada número de la pareja (cuidando los cuadrados perfectos). Entonces, la ecuación de recurrencia nos quedaría:</p>

<ul>
  <li><em>opt(n) = 0</em> si <em>n == 0</em>;</li>
  <li>1 si <em>n</em> cuadrado perfecto;</li>
  <li><em>min(opt(n-i) + opt(i))</em>, para <em>i</em> en <em>[1; n-1]</em> en otro caso</li>
</ul>

<p>El código de la resolución recursiva sería:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">minimos_terminos</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">es_cuadrado_perfecto</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="c1">#opcion con todos 1s
</span>    <span class="n">mejor</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">mejor</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mejor</span><span class="p">,</span> <span class="n">minimos_terminos</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">minimos_terminos</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mejor</span>
</code></pre></div></div>

<p>Como vemos, se hacen muchísimos llamados resursivos (para 74 se hacen para 1 y 73, 2 y 72, etc.. y dentro de estos también se hacen muchos). Si ya tuviéramos calculados los términos para todos los valores anteriores, esto podría evitarse. Entonces, simplemente hacemos:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">minimos_terminos</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1">#arreglo en el que guardaremos los resultados
</span>    <span class="nb">int</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">1.</span><span class="p">.</span> <span class="n">n</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">es_cuadrado_perfecto</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="c1">#inicialmente ponemos la solución que seguro existe
</span>        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1">#Podria iterarse solo hasta la mitad, porque vamos a repetir combinaciones:
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">1.</span><span class="p">.</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</code></pre></div></div>

<p>Claramente esta solución es mucho mejor que la anterior. En espacio es muy fácil de ver que es \(\mathcal{O}(n)\), dado el arreglo auxiliar que estamos utilizando, mientras que en tiempo podríamos decir que es:
\(\mathcal{O}(n * (n + \mathcal{O}(es\_cuadrado\_perfecto)))\). La función <code class="language-plaintext highlighter-rouge">es_cuadrado_perfecto</code> se puede implementar trivialmente con un orden \(\mathcal{O}(\sqrt{n})\), aunque también se podría hacer en \(\mathcal{O}(\log n)\). En cualquier caso, es claramente despreciable al lado del \(\mathcal{O}(n)\) de la segunda iteración, por lo que el algoritmo será finalmente \(\mathcal{O}(n^2)\).</p>

<h4 id="opción-2">Opción 2</h4>

<p>Una mejora importante es simplemente restar los cuadrados perfectos. Si yo sé que \(10 = 9 + 1^2 = 6 + 2^2 = 1 + 3^2\), sabemos que el segundo término de cada igualdad es ya de por sí un término cuadrático (por ende, se escribe con un solo término). Si supiéramos la cantidad óptima para 9, para la primera opción solo tendríamos que decir <code class="language-plaintext highlighter-rouge">opt1(10) = opt(9) + 1</code>. Para la segunda opción, si tuviéramos el óptimo para 6, el óptimo para esa opción sería la cantidad óptima para 6, más 1 por el \(2^2\) (se escribe en un solo término, esa es la gracia). Entonces, la ecuación de recurrencia nos quedaría:
<code class="language-plaintext highlighter-rouge">opt(n) = 0 si n == 0; min(opt(n-i^2) + 1), para i tal que i^2 &lt;= n, en otro caso</code></p>

<p>(Notar que los cuadrados perfectos van a ser tenidos en cuenta ya que al hacer, por ejemplo, \(9 = 0 + 3^2\), el 0 no agrega término).</p>

<p>Obviando la implementación recursiva (la dejamos de tarea, pero será muy parecida a la anterior), la solución optimizada será:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">terminos</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="nb">int</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">1.</span><span class="p">.</span> <span class="n">n</span><span class="p">]:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1">#veo todos los cuadrados perfectos menores o iguales a i:
</span>        <span class="k">while</span> <span class="n">j</span><span class="o">*</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</code></pre></div></div>

<p>Sobre el orden, es fácil primero pensar que es \(\mathcal{O}(n^2)\). A los fines de un parcialito, si alguien escribiera esto para dicha solución, sería visto como correcto.</p>

<p>Ahora bien, en realidad si bien el primer for se itera <em>n</em> veces, el while no itera <em>n</em> veces, sino que itera por los cuadrados perfectos anteriores. La variable <em>j</em> a lo sumo va a valer la raíz cuadrada de <em>i</em>. Eso implica que ese for se itera \(\sqrt{i}\) veces, por lo tanto el orden va a ser \(\mathcal{O}(n * \sqrt{n}) = \mathcal{O}(n^{1.5})\).</p>

<p>Otra forma de verlo, es que este ejercicio es <em>muy similar</em> al problema del cambio. Supongamos que nuestras monedas fueran los infinitos cuadrados perfectos (o con considerar hasta el próximo al <em>N</em> que nos interese, sería suficiente). Antes tratábamos de formar el cambio con las monedas que teníamos, ahora tratamos de formar un número con los cuadrados perfectos. Se puede ver que hay una equivalencia directa, teniendo de monedas el 1, 4, 9, 16, 25, …
A su vez, también se puede ver que la solución greedy para el problema del cambio no aplicaría para este problema (al menos de forma óptima), puesto que no se cumple la propiedad de tener que una moneda sea al menos del doble de valor que su anterior.</p>

<h2 id="ejercicios-propuestos">Ejercicios propuestos</h2>

<ol>
  <li>
    <p>La cantidad de posibles colocaciones de paréntesis para n operadores binarios está dada por la fórmula:</p>

    <p>\(v[n] = \sum_{j=0}^{n-1} v[j] * v[(n-1)-j]\), con \(v[0] = 1\) y \(v[1] = 1\)</p>

    <p>Escribir una función que obtenga la cantidad de agrupaciones para un valor N de operadores de forma eficiente.</p>
  </li>
  <li>
    <p>Dado el binomio \((a + b)^n\) (donde <em>n</em> es nuestra variable), queremos conocer todos los coeficientes resultantes de desarrollar el mismo.</p>

    <p>Tener en cuenta que: \((a + b)^n = \sum_{k=0}^n \binom{n}{k} a^{n} \times b^{n-k}\)</p>

    <p>Por lo tanto, lo que nos interesa conocer son los valores de todos esos combinatorios. Sabiendo que:</p>
    <ul>
      <li>\(\binom{n}{0} = 1\).</li>
      <li>\(\binom{n}{n} = 1\).</li>
      <li>\(\binom{n}{k} = \binom{n-1}{k} + \binom{n-1}{k-1}\) (en otro caso).</li>
    </ul>

    <p>Implementar un algoritmo que por programación dinámica nos permita obtener todos los coeficientes de un binomio de grado <em>n</em>.</p>
  </li>
  <li>
    <p>Juan es ambicioso pero también algo vago. Dispone de varias ofertas de trabajo diarias, pero no quiere trabajar dos días seguidos. Dado un arreglo con el monto esperado a ganar cada día, determinar por programación dinámica el máximo monto a ganar, sabiendo que no aceptará trabajar dos días seguidos.</p>

    <p>Por ejemplo, si el arreglo es <code class="language-plaintext highlighter-rouge">[100, 20, 30, 70, 50]</code> el monto máximo que podrá ganar serán $180 (trabajar el primer, tercer y quinto día). En cambio, si el arreglo fuera <code class="language-plaintext highlighter-rouge">[100, 20, 30, 70, 20]</code>, el monto máximo a ganar serían $170 (resultado de trabajar el primer y cuarto día).</p>

    <p><em>Aclaración</em>: estos fueron tan solo ejemplos, no quiere decir que el arreglo vaya a tener tan solo 5 elementos.</p>
  </li>
  <li>
    <p>Se tiene una grilla de <code class="language-plaintext highlighter-rouge">MxN</code> casilleros. Si solo se puede comer hacia abajo y hacia la derecha:</p>

    <ol>
      <li>Determinar la cantidad de caminos posibles que hay para llegar desde el casillero <code class="language-plaintext highlighter-rouge">(0, 0)</code> hasta el casillero <code class="language-plaintext highlighter-rouge">(M-1, N-1)</code>.</li>
      <li>Idem anterior, pero teniendo en cuenta que hay casilleros (conocidos) sobre los que no se puede pisar (hay obstáculos).</li>
      <li>Si en cada casillero hubiera una cantidad de dinero (que pudiera ser 0) que se puede recoger, determinar la máxima cantidad de dinero que se puede obtener partiendo desde el casillero <code class="language-plaintext highlighter-rouge">(0, 0)</code> hasta el <code class="language-plaintext highlighter-rouge">(M-1, N-1)</code>.</li>
      <li>Idem anterior, pero sabiendo que además hay obstáculos en algunos casilleros (símil al inciso b).</li>
    </ol>
  </li>
  <li>
    <p>Dado un conjunto de números positivos <em>L</em> y un número <em>n</em>, determinar si existe un subconjunto de <em>L</em> que sume exactamente <em>n</em>.</p>
  </li>
  <li>
    <p>¡Ejercicio difícil! En este barrio todos viven alrededor de la plaza y los vecinos contiguos se odian entre sí. Hay <em>n</em> vecinos y el primer vecino es contiguo con el último. Cuando le preguntan a cada uno cuánto es lo máximo que va a donar para arreglar la plaza la respuesta se registra en el array <code class="language-plaintext highlighter-rouge">donar = [d0, d1, ..., d(n-1)]</code>, pero la condición es: solo donaré si no dona ninguno de mis vecinos contiguos.</p>

    <p>Usando programación dinámica resolver cuánto es lo máximo que se puede recolectar por donaciones.</p>
  </li>
</ol>

<h2 id="bibliografía-y-referencias">Bibliografía y referencias</h2>

<ul>
  <li>Weiss, Mark Allen: “Data Structures and Algorithms” (tercera edición), Pearson, 1999. Cap. 10.3: <em>Dynamic programming</em>.</li>
  <li>Guerequeta, Rosa; Vallecillo, Antonio: “Técnicas de Diseño de Algoritmos” (segunda edición), Servicio de Publicaciones de la Universidad de Málaga, 1998. Cap 5: <em>Programación dinámica</em>.</li>
  <li>Cormen, Thomas; Leiserson, Charles; Rivest, Ronald; Stein, Clifford: “Introduction to Algorithms” (tercera edición), MIT Press, 2009. Cap. 15: <em>Dynamic programming</em>.</li>
</ul>


        </div>
      </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.slim.min.js"
        integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8=" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.bundle.min.js"
        integrity="sha384-6khuMg9gaYr5AxOqhkVIODVIvm9ynTT5J4V1cfthmT+emCG6yVmEZsRHdxlotUnm" crossorigin="anonymous"></script>

  </body>

</html>
