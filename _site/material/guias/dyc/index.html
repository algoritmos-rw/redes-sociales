<!DOCTYPE html>
<html lang="es">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>División y Conquista</title>
  <meta name="description" content="Página de la materia Algoritmos y Programación II, curso Buchwald. Facultad de Ingeniería, Universidad de Buenos Aires.">

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        crossorigin="anonymous" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
  <link rel="stylesheet" href="/algo2/assets/main.css" type="text/css" />
  <link rel="shortcut icon" href="/algo2/assets/img/favicon.ico" type="image/x-icon">
  <!-- <link rel="canonical" href="http://localhost:4000/algo2/material/guias/dyc/"> -->

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
        crossorigin="anonymous" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
          crossorigin="anonymous" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
          crossorigin="anonymous" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"
          onload="renderMathInElement(document.body);"></script>
  
</head>


  <body>
    <header role="banner" class="sticky-top container-fluid px-1">
  <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <a class="navbar-brand d-lg-none" href="#">Algoritmos y Programación II</a>
    <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#sitenav"
            aria-controls="sitenav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="sitenav">
      <ul class="navbar-nav mr-auto mt-2 mt-lg-0 small mx-auto">
        <li class="nav-item "><a class="nav-link" href="/algo2/"><span class="fa fa-home"></span> Inicio</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/docentes/"><span class="fa fa-chalkboard-teacher"></span> Docentes</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/regimen/"><span class="fa fa-tasks"></span> Régimen</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/calendario/"><span class="fa fa-calendar-alt"></span> Calendario</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/tps/"><span class="fa fa-briefcase"></span> TPs</a></li>
        
        <li class="nav-item dropdown ">
          <a class="nav-link dropdown-toggle" href="#" role="button" id="matDropdown"
                                              data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <span class="fa fa-paperclip"></span> Material</a>
          <ul class="dropdown-menu">
            <li class=""><a class="dropdown-item" href="/algo2/bibliografia/"><span class="fa fa-book"></span> Bibliografía</a></li>
            <li class=""><a class="dropdown-item" href="/algo2/material/"><span class="fa fa-book-reader"></span> Apuntes del curso</a></li>
            <li class=""><a class="dropdown-item" href="/algo2/material/guias/"><span class="fa fa-dumbbell"></span> Guías de ejercicios</a></li>
            <li>
              <a class="dropdown-item" href="https://drive.google.com/drive/folders/0B0x0VPz_v-f_ekhhQUpkay13RnM?resourcekey=0-BqMLnLNd6T8lRDzv-VL4xA&usp=sharing" target="_blank"><span class="fab fa-google-drive"></span> Drive</a>
            </li>
            <li>
              <a class="dropdown-item" href="https://www.youtube.com/channel/UCnmq-CGB2lEiwxhpa_Q63qQ" target="_blank"><span class="fab fa-youtube"></span> Canal</a>
            </li>
            <li><a class="dropdown-item" href="/algo2/faq/"><span class="fas fa-question-circle"></span> FAQ</a></li>
          </ul>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" role="button" id="aluDropdown"
                                              data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <span class="fa fa-user-friends"></span> Alumno</a>
          <ul class="dropdown-menu">
            <li><a class="dropdown-item" href="https://algoritmos-rw.github.io/algo2_skel"><span class="fa fa-file-download"></span> Descargas</a></li>
            <li><a class="dropdown-item" href="https://algoritmos-rw.dijkstra.ar/entregas/"><span class="fa fa-file-upload"></span> Entregas</a></li>
            <li><a class="dropdown-item" href="https://algoritmos-rw.dijkstra.ar/notas/"><span class="fa fa-pencil-alt"></span> Notas</a></li>
          </ul>
        </li>
        <li class="nav-item "><a class="nav-link" href="/algo2/encuestas/"><span class="fa fa-poll"></span> Encuestas</a></li>
        <li class="nav-item "><a class="nav-link" href="/algo2/infraestructura/"><span class="fa fa-network-wired"></span> Infraestructura</a></li>
        <li class="nav-item">
          <a href="https://github.com/algoritmos-rw/algo2/blob/master/material/guias/dyc.md" class="nav-link" target="_blank"><span class="fab fa-github"></span> Editar en GitHub</a>
        </li>
      </ul>
    </div>
  </nav>
</header>


    <main class="container" role="main">
      <div class="row justify-content-center">
        <div class="col col-xl-8">
          <h1 class="no_toc" id="división-y-conquista">División y Conquista</h1>

<h2 class="no_toc" id="contenidos">Contenidos</h2>

<ol id="markdown-toc">
  <li><a href="#ejercicio-resuelto" id="markdown-toc-ejercicio-resuelto">Ejercicio resuelto</a></li>
  <li><a href="#ejercicios-propuestos" id="markdown-toc-ejercicios-propuestos">Ejercicios propuestos</a></li>
</ol>

<h2 id="ejercicio-resuelto">Ejercicio resuelto</h2>

<p>Implementar un algoritmo en C que reciba un arreglo de enteros de tamaño \(n\), ordenado ascendentemente y sin elementos repetidos, y determine en \(\mathcal{O}(\log n)\) si es mágico. Un arreglo es mágico si existe algún valor \(i\) tal que \(0 \le i \lt n\) y <code class="language-plaintext highlighter-rouge">arr[i] = i</code>. Justificar el orden del algoritmo.</p>

<p>Ejemplos:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">A = [ -3, 0, 1, 3, 7, 9 ]</code> es mágico porque <code class="language-plaintext highlighter-rouge">A[3] = 3</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">B = [ 1, 2, 4, 6, 7, 9 ]</code> no es mágico porque <code class="language-plaintext highlighter-rouge">B[i] != i</code> para todo <code class="language-plaintext highlighter-rouge">i</code>.</p>
  </li>
</ul>

<h3 id="solución">Solución</h3>

<p>Como es mencionado en clase, al ver que se nos pide:</p>

<ul>
  <li>
    <p>Un algoritmo de división y conquista,</p>
  </li>
  <li>
    <p>Un orden \(\mathcal{O}(\log n)\)</p>
  </li>
</ul>

<p>Si no se nos pidiera que sea de división y conquista, y más aún que su orden sea logarítimico, podríamos simplemente ir elemento por elemento chequeando si se cumple la condición:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">ArregloEsMagico</span><span class="p">(</span><span class="n">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">i</span> <span class="p">{</span>
            <span class="k">return</span> <span class="no">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Por supuesto, esta sería la solución <em>trivial</em>, casi con nulo esfuerzo de pensar y aprovechar la cualidad de que el
arreglo se encuentre ordenado y sin repetidos. Se podría hasta implementar con división y conquista, pero no dejará
de ser \(\mathcal{O}(n)\). Como en otros problemas, vamos a buscar aprovechar las precondiciones que nos dan para el
arreglo.</p>

<p>Lo primero que tenemos que pensar es en el algoritmo <em>estrella</em> de división y conquista que tiene ese orden: Búsqueda Binaria. Al ver que se nos pide eso, seguramente nuestro algoritmo no sea muy distinto al de búsqueda binaria (o bien, que la forma de la función va a ser similar). Pero para poder aplicar un algoritmo así, necesariamente tenemos que poder desechar toda una proporción del problema original en cada iteración. Ya vemos que tenemos la condición de que el arreglo se encuentra ordenado ascendentemente, y no cuenta con repetidos. Veremos si esa última restricción es realmente necesaria, pero al menos con la primera ya contamos con una restricción bastante fuerte.</p>

<p>Lo primero a pensar es el caso base: si se nos da vuelta el inicio y fin, significa que nunca nos topamos con un índice que cumpla la condición (no siempre va a ser este nuestro caso base, ojo).</p>

<p>Ahora, lo crucial: pensar la condición de éxito. Acá es donde analizamos qué resuelve nuestro algoritmo. Vamos al medio, y lo que tenemos que verificar es si <code class="language-plaintext highlighter-rouge">arr[medio] == medio</code>. Si eso sucede, ¡éxito! Entonces, por ahora tenemos:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">ArregloEsMagico</span><span class="p">(</span><span class="n">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">arregloEsMagico</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">arregloEsMagico</span><span class="p">(</span><span class="n">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">inicio</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fin</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">inicio</span> <span class="o">&gt;</span> <span class="n">fin</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">medio</span> <span class="o">:=</span> <span class="p">(</span><span class="n">inicio</span> <span class="o">+</span> <span class="n">fin</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">==</span> <span class="n">medio</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">true</span>
    <span class="p">}</span>
    <span class="c">// nos falta el caso sin exito</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ahora, pensemos que eso no sucede. Necesitamos quedarnos con una sola de las mitades, lo cual implica descartar la otra. Pero ¿cómo descartamos una mitad? Bueno, podemos ver qué pasó con <code class="language-plaintext highlighter-rouge">arr[medio]</code> que no cumple con la condición de éxito. ¿Qué sucede si <code class="language-plaintext highlighter-rouge">arr[medio] &lt; medio</code>? ¿Puede suceder que algún elemento anterior sí cumpla la condición? <strong>¡NO!</strong>, porque al no poder haber repetidos, si <code class="language-plaintext highlighter-rouge">arr[medio] &lt; medio</code>, entonces <code class="language-plaintext highlighter-rouge">arr[medio - 1] &lt; medio - 1</code>, y tambien para todos los anteriores. Por eso, podemos simplemente ver de la mitad en adelante, descartando la primera mitad. Ahí vemos que la condición extra era necesaria; si no, no podríamos descartar la primera mitad. Podemos hacer el mismo análisis al revés, vamos a ver que si <code class="language-plaintext highlighter-rouge">arr[medio] &gt;  medio</code>, no puede ser que se cumpla la condición para los elementos siguientes.</p>

<p>Luego de este análisis, podemos escribir el código:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">ArregloEsMagico</span><span class="p">(</span><span class="n">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">arregloEsMagico</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">arregloEsMagico</span><span class="p">(</span><span class="n">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">inicio</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fin</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">inicio</span> <span class="o">&gt;</span> <span class="n">fin</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">medio</span> <span class="o">:=</span> <span class="p">(</span><span class="n">inicio</span> <span class="o">+</span> <span class="n">fin</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">==</span> <span class="n">medio</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">true</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">medio</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_arreglo_es_magico</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">medio</span> <span class="o">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">fin</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_arreglo_es_magico</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">inicio</span><span class="p">,</span> <span class="n">medio</span> <span class="o">-</span> <span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="demostración-del-orden">Demostración del orden</h4>

<p>Veamos la ecuación de recurrencia. Hay escritos dos llamados recursivos, cada uno se invoca con la mitad del problema (mitad
izquierda o derecha), y todo lo que cuesta <em>partir y juntar</em> no son más que algunas operaciones básicas de tiempo constante.
Lo importante es que si bien hay escritos dos llamados recursivos, nunca se llamará a ambos. Siempre se llamará bien
para el lado izquierdo, bien para el derecho. Por lo tanto, la ecuación de recurrencia quedará:</p>

\[\mathcal{T}(n) = \mathcal{T}\left(\frac{n}{2}\right) + \mathcal{O}(1)\]

<p>Es, evidentemente, igual a la de Búsqueda Binaria, por lo que tendrá el mismo orden, pero aplicamos el Teorema Maestro para corroborar:</p>

\[A = 1; B = 2; C = 0 \rightarrow \log_B (A) = \log_2 (1) = 0 = C\]

<p>Caemos en el caso de \(\log_B (A) = C\), por lo que el orden del algoritmo será \(\mathcal{O}(n^C \log n) = \mathcal{O}(\log n)\)</p>

<h2 id="ejercicios-propuestos">Ejercicios propuestos</h2>

<ol>
  <li>
    <p>(★) Explicar por qué el siguiente siguiente código <strong>no</strong> es de división y conquista.</p>

    <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Algoritmo ¿por D&amp;C? para obtener el máximo de un arreglo</span>
<span class="k">func</span> <span class="n">maximo</span><span class="p">(</span><span class="n">arreglo</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">arreglo</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">max_restante</span> <span class="o">:=</span> <span class="n">maximo</span><span class="p">(</span><span class="n">arreglo</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">arreglo</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_restante</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">arreglo</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">max_restante</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(★) Explicar por qué el siguiente siguiente código <strong>no</strong> es de división y conquista.</p>

    <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Algoritmo ¿por D&amp;C? para obtener el máximo de un arreglo</span>
<span class="k">func</span> <span class="n">maximo</span><span class="p">(</span><span class="n">arreglo</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">medio</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span>
    <span class="n">max_izquierda</span> <span class="o">:=</span> <span class="n">_maximo</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">medio</span><span class="p">)</span>
    <span class="n">max_derecha</span> <span class="o">:=</span> <span class="n">_maximo</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">medio</span> <span class="o">+</span> <span class="m">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_izquierda</span> <span class="o">&gt;</span> <span class="n">max_derecha</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">max_izquierda</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">max_derecha</span>
    <span class="p">}</span>
<span class="p">}</span>
    
<span class="k">func</span> <span class="n">_maximo</span><span class="p">(</span><span class="n">arreglo</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">inicio</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fin</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">max</span> <span class="o">:=</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">inicio</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">inicio</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">fin</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">max</span> <span class="o">&lt;</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">max</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(★★) Indicar la complejidad del siguiente algoritmo, utilizando el teorema maestro:</p>

    <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Busca un elemento usando D&amp;C. El arreglo se encuentra ordenado.</span>
<span class="k">func</span> <span class="n">elementoEsta</span><span class="p">(</span><span class="n">arreglo</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">inicio</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fin</span> <span class="kt">int</span><span class="p">,</span> <span class="n">elem</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">inicio</span> <span class="o">&gt;</span> <span class="n">fin</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>
    <span class="n">medio</span> <span class="o">:=</span> <span class="p">(</span><span class="n">inicio</span> <span class="o">+</span> <span class="n">fin</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span>
    <span class="k">if</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">==</span> <span class="n">medio</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">true</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">elem</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">elementoEsta</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">medio</span> <span class="o">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">fin</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">medio</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">inicio</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">elem</span> <span class="p">{</span>
            <span class="k">return</span> <span class="no">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(★) Hacerle el seguimiento al siguiente algoritmo:</p>

    <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">imprimirDyC</span><span class="p">(</span><span class="n">m</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="m">4</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">imprimirDyC</span><span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="m">4</span><span class="p">)</span>
    <span class="n">imprimirDyC</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="m">4</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(★) Indicar, utilizando el Teorema Maestro, la complejidad del ejercicio anterior.</p>
  </li>
  <li>
    <p>(★★) Indicar cuál es la complejidad de un algoritmo cuya ecuación de recurrencia es:
\(\mathcal{T} = 2 \mathcal{T}\left(\frac{2}{3}n\right) + \mathcal{O}\left(\sqrt{n}\right)\).</p>
  </li>
  <li>(★★) Nos dan para elegir entre los siguientes 3 algoritmos para solucionar el mismo problema.
¿Cuál elegirías? Justificar calculando el orden de los algoritmos.
    <ol class="lower_alpha">
      <li>El algoritmo <code class="language-plaintext highlighter-rouge">A</code> resuelve el problema dividiéndolo en 5 subproblemas de la mitad del tamaño,
resolviendo cada subproblema de forma recursiva, y combinando las soluciones en tiempo lineal.</li>
      <li>El algoritmo <code class="language-plaintext highlighter-rouge">B</code> resuelve el problema (de tamaño \(n\)) dividiéndolo en 9 subproblemas de tamaño
\(\frac{n}{3}\), resolviendo cada subproblema de forma recursiva y combinando las soluciones en
tiempo cuadrático de \(n\).</li>
      <li>El algoritmo <code class="language-plaintext highlighter-rouge">C</code> resuelve el problema (de tamaño \(n\)) eligiendo un subproblema de tamaño
\(n - 1\) en tiempo \(\mathcal{O}(n)\), y luego resolviendo recursivamente ese subproblema.</li>
    </ol>
  </li>
  <li>
    <p>(★★) Implementar, por división y conquista, una función que determine el mínimo de un arreglo.
Indicar y justificar el orden.</p>
  </li>
  <li>
    <p>(★★) Implementar, por división y conquista, una función que dado un arreglo y su largo, determine si el mismo
se encuentra ordenado. Indicar y justificar el orden.</p>
  </li>
  <li>
    <p>(★★) Implementar, por división y conquista, una función que dado un arreglo sin elementos repetidos y <em>casi ordenado</em> (todos los elementos se
encuentran ordenados, salvo uno), obtenga el elemento fuera de lugar. Indicar y justificar el orden.</p>
  </li>
  <li>(★★★) Se tiene un arreglo tal que <code class="language-plaintext highlighter-rouge">[1, 1, 1, ..., 0, 0, ...]</code> (es decir, <em>unos seguidos de ceros</em>). Se pide:
    <ol class="lower_alpha">
      <li>una función de orden \(\mathcal{O}(\log n)\) que encuentre el índice del primer 0. Si no hay ningún 0 (solo hay unos), debe devolver -1.</li>
      <li>demostrar con el Teorema Maestro que la función es, en efecto, \(\mathcal{O}(\log n)\).</li>
    </ol>

    <p>Ejemplos:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 1, 0, 0, 0] →  2
[0, 0, 0, 0, 0] →  0
[1, 1, 1, 1, 1] → -1
</code></pre></div>    </div>
  </li>
  <li>
    <p>(★★★★) Implementar un algoritmo que, por división y conquista, permita obtener la parte entera de la raíz cuadrada de
un número \(n\), en tiempo \(\mathcal{O}(\log n)\). Por ejemplo, para \(n = 10\) debe devolver 3, y para \(n = 25\)
debe devolver 5.</p>
  </li>
  <li>(★★★) Se tiene un arreglo de \(N &gt;= 3\) elementos en forma de pico, esto es: estrictamente creciente hasta una
determinada posición \(p\), y estrictamente decreciente a partir de ella (con \(0 \lt p \lt N - 1\)). Por ejemplo,
en el arreglo <code class="language-plaintext highlighter-rouge">[1, 2, 3, 1, 0, -2]</code> la posición del pico es \(p = 2\). Se pide:
    <ol class="lower_alpha">
      <li>Implementar un algoritmo de división y conquista de orden \(\mathcal{O}(\log n)\) que encuentre la posición
\(p\) del pico: <code class="language-plaintext highlighter-rouge">size_t posicion_pico(int v[], size_t ini, size_t fin);</code>. La función será invocará inicialmente como:
<code class="language-plaintext highlighter-rouge">posicion_pico(v, 0, n-1)</code>, y tiene como pre-condición que el arreglo tenga forma de pico.</li>
      <li>Justificar el orden del algoritmo mediante el teorema maestro.</li>
    </ol>
  </li>
  <li>(★★) Se quiere implementar MergeSort pero, en vez de dividir en dos partes el arreglo, dividirlo en tres, llamando
recursivamente al algoritmo para cada una de las partes y luego uniéndolas.
    <ol class="lower_alpha">
      <li>Suponiendo que el merge de las tres partes se realiza en tiempo lineal, calcular el orden del algoritmo.</li>
      <li>Si en vez de dividir en tres partes, se dividiera el arreglo en \(n\), siendo \(n\) la cantidad de elementos del arreglo ¿a qué otro algoritmo de ordenamiento se asemeja esta implementación? ¿Cuál es el orden de dicho algoritmo?</li>
      <li>Dado lo obtenido en los puntos anteriores ¿tiene sentido implementar MergeSort con \(k\) separaciones, para \(k &gt; 2\)?</li>
    </ol>
  </li>
  <li>
    <p>(★★★) Un algoritmo sencillo para multiplicar matrices de \(n \times n\) demora \(\mathcal{O}(n^3)\).
El algoritmo de Strassen (que utiliza División y Conquista) lo hace en \(\mathcal{O}(n^{\log_2 7})\).
La profesora Manterola quiere implementar un algoritmo de División y Conquista que sea aún más veloz,
donde divida al problema en <code class="language-plaintext highlighter-rouge">A</code> subproblemas de tamaño de \(\frac{n}{4}\), y que juntar las soluciones
parciales sea \(\mathcal{O}(n^2)\).
¿Cuál es el máximo <code class="language-plaintext highlighter-rouge">A</code> para que el orden del algoritmo sea menor que el del algoritmo de Strassen?
Justificar.</p>
  </li>
  <li>
    <p>(★★★★) En Bytelandia tienen un sistema monetario extraño: su divisa es el
bytelandés, y existen denominaciones en moneda física… ¡para todos
los valores enteros! (Esto es, se emiten monedas de 1, 2, 3, …, 14, 15, …,
28, 29, 30, … bytelandeses). No solo eso, <em>cualquier</em> moneda de valor
\(n\) puede cambiarse en el banco por 3 monedas de menor denominación,
de valores \(\lfloor\frac{n}{2}\rfloor\), \(\lfloor\frac{n}{3}\rfloor\)
y \(\lfloor\frac{n}{4}\rfloor\) respectivamente (no existe denominación de 0 pesos,
por lo cual es posible recibir menos de 3 monedas en el cambio); una vez hecho
el cambio, sin embargo, no pueden cambiarse de vuelta por la moneda
mayor (e.g., no pueden cambiase una moneda de 2 y otra de 3 por una
de 5). Finalmente, también es posible intercambiar bytelandeses por
pesos argentinos, a una tasa de 1 a 1.
Se pide implementar un algoritmo que, utilizando <strong>división y conquista</strong>, reciba el valor
\(n\) de una moneda en bytelandés y devuelva la cantidad máxima de pesos argentinos que
se podría obtener realizando los intercambios arriba mencionados. Por ejemplo, si
\(n = 12\), la cantidad máxima de pesos que se puede obtener es $13, ya que podemos dividir
la moneda de 12 bytelandeses en monedas de 6, 4 y 3; y $6 + $4 + $3 = $13 (se podría seguir
dividiendo, pero en este caso no conviene dividir ninguna de esas monedas resultantes).
Justificar el orden del algoritmo implementado.</p>
  </li>
  <li>
    <p>(★★★★★) Implementar una función (que utilice división y conquista) de orden \(\mathcal{O}(n \log n)\)
que dado un arreglo de \(n\) números enteros devuelva <code class="language-plaintext highlighter-rouge">true</code> o <code class="language-plaintext highlighter-rouge">false</code> según si existe algún elemento que aparezca
más de la mitad de las veces. Justificar el orden de la solución. Ejemplos:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 1, 2, 3] -&gt; false
[1, 1, 2, 3] -&gt; false
[1, 2, 3, 1, 1, 1] -&gt; true
[1] -&gt; true
</code></pre></div>    </div>

    <p><em>Aclaración</em>: Este ejercicio puede resolverse, casi trivialmente, ordenando el arreglo con un algoritmo eficiente,
o incluso se puede realizar más rápido utilizando una <a href="/algo2/material/guias/hash/">tabla de hash</a>. Para hacer interesante el ejercicio,
resolver <strong>sin ordenar el arreglo</strong>, sino puramente división y conquista.</p>
  </li>
  <li>
    <p>(★★★★★) Tenemos un arreglo de tamaño <code class="language-plaintext highlighter-rouge">2n</code> de la forma <code class="language-plaintext highlighter-rouge">{C1, C2, C3, … Cn, D1, D2, D3, … Dn}</code>, 
tal que la cantidad total de elementos del arreglo es potencia de 2 (por ende, <code class="language-plaintext highlighter-rouge">n</code> 
también lo es). Implementar un algoritmo de División y Conquista que modifique el arreglo 
de tal forma que quede con la forma <code class="language-plaintext highlighter-rouge">{C1, D1, C2, D2, C3, D3, …, Cn, Dn}</code>, <strong>sin utilizar 
espacio adicional</strong> (obviando el utilizado por la recursividad). ¿Cual es la complejidad 
del algoritmo?</p>

    <p><em>Pista</em>: Pensar primero cómo habría que hacer si el arreglo tuviera 4 elementos 
(<code class="language-plaintext highlighter-rouge">{C1, C2, D1, D2}</code>). Luego, pensar a partir de allí el caso de 8 elementos, etc…
para encontrar el patrón.</p>
  </li>
  <li>
    <p>(★★★★) Debido a la trágica situación actual, es necesario realizar tests para detectar
si alguna persona está contagiada de COVID-19. El problema es que los insumos
tienden a ser bastante caros, y no vivimos en un país al que los recursos le sobren.</p>

    <p>Supongamos que por persona se toma más de una muestra (lo cual es cierto, pero a fines
del ejercicio supongamos que son muchas muestras), y que podemos realizar un testeo a más 
de una persona al mismo tiempo mezclando las muestras (lo cual también es cierto): 
determinamos un conjunto de personas a testear, obtenemos una muestra de cada una de ellas,
las “juntamos”, y al conjunto le realizamos el test. Si el test resulta negativo, 
implica que todas las personas testeadas en conjunto resultaron negativas. Si resulta 
positivo, implica que al menos una de las personas testedas resulta positiva.</p>

    <p>Suponer que existe una función <code class="language-plaintext highlighter-rouge">pcr(grupo)</code>, que devuelve <code class="language-plaintext highlighter-rouge">true</code> si al menos una persona
del <code class="language-plaintext highlighter-rouge">grupo</code> es COVID-positivo, y <code class="language-plaintext highlighter-rouge">false</code> en caso contrario (los <code class="language-plaintext highlighter-rouge">grupos</code> pueden estar
formados por 1 o más personas). Suponer que la positividad es extremadamente baja, e inclusive
pueden suponer que va a haber una única persona contagiada (por simplicidad).</p>

    <p>Implementar un algoritmo que dado un conjunto de <code class="language-plaintext highlighter-rouge">n</code> personas, devuelva la o las personas
contagiadas, utilizando la menor cantidad de tests posibles (considerando la notación Big Oh).
En dicha notación, ¿cuántos tests se estarán utilizando?</p>

    <p>Pueden considerar que habrá una única persona contagiada, pero esto no cambiará el análisis
a realizar.</p>
  </li>
  <li>(★★★★) Se sabe, por el teorema de Bolsano, que si una función es continua en un intervalo <code class="language-plaintext highlighter-rouge">[a, b]</code>, 
y que en el punto <code class="language-plaintext highlighter-rouge">a</code> es positiva y en el punto <code class="language-plaintext highlighter-rouge">b</code> es negativa (o viceversa), necesariamente
debe haber (al menos) una raíz en dicho intervalo. Implementar una función 
<code class="language-plaintext highlighter-rouge">int raiz(int (*f)(int), int a, int b)</code> que reciba una función (univariable) y
los extremos mencionados y devuelva una raíz dentro de dicho intervalo (si hay más de una, 
simplemente quedarse con una). La complejidad de dicha función debe ser logarítmica del
largo del intervalo <code class="language-plaintext highlighter-rouge">[a, b]</code>. Asumir que por más que se esté trabajando con números enteros, 
hay raíz en dichos valores: Se puede trabajar con <code class="language-plaintext highlighter-rouge">floats</code>, y el algoritmo será equivalente, 
simplemente se plantea con <code class="language-plaintext highlighter-rouge">ints</code> para no generar confusiones con la complejidad.
Justificar la complejidad de la función implementada.</li>
</ol>



        </div>
      </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.slim.min.js"
        integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8=" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.bundle.min.js"
        integrity="sha384-6khuMg9gaYr5AxOqhkVIODVIvm9ynTT5J4V1cfthmT+emCG6yVmEZsRHdxlotUnm" crossorigin="anonymous"></script>

  </body>

</html>
